<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Sahibnoor Singh">

<title>Offensive Language on Twitter During the 2024 U.S. Election</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="report_files/libs/clipboard/clipboard.min.js"></script>
<script src="report_files/libs/quarto-html/quarto.js"></script>
<script src="report_files/libs/quarto-html/popper.min.js"></script>
<script src="report_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="report_files/libs/quarto-html/anchor.min.js"></script>
<link href="report_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="report_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="report_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="report_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="report_files/libs/bootstrap/bootstrap-c0367b04c37547644fece4185067e4a7.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Offensive Language on Twitter During the 2024 U.S. Election</h1>
<p class="subtitle lead">Computational Social Science</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Sahibnoor Singh </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">Invalid Date</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<!-- 
  Quarto processes everything above as YAML for document metadata.
  Below is the document body. 
-->
<!-- Page 1: Title Page -->
<section id="abstract" class="level1">
<h1>Abstract</h1>
<p>Write your abstract here. Typically, an abstract is a concise summary of your paper, including motivation, key points, and main findings in a short paragraph or two.</p>
<!-- Page 3: Table of Contents -->
</section>
<section id="table-of-contents" class="level1">
<h1>Table of Contents</h1>
<ol type="1">
<li><a href="#introduction-and-motivation">Introduction and Motivation</a><br>
</li>
<li><a href="#data-and-methods">Data and Methods</a><br>
</li>
<li><a href="#results">Results</a><br>
</li>
<li><a href="#appendix">Appendix</a><br>
</li>
<li><a href="#references">References</a></li>
</ol>
<!-- Page 4: Introduction and Motivation -->
</section>
<section id="introduction-and-motivation" class="level1">
<h1>Introduction and Motivation</h1>
<p>Offensive Language on Twitter During the 2024 U.S. Election</p>
<p>Introduction</p>
<p>The rapid expansion of social media platforms has dramatically reshaped the landscape of political communication and public discourse. Twitter, in particular, serves as a real-time bulletin board where political figures, media outlets, and ordinary citizens exchange information and engage in debate. While this increased connectivity has democratized the flow of information, it has also facilitated the unchecked spread of problematic content, such as hate speech, trolling, and other forms of offensive language. These dynamics take on heightened importance during major political events, such as the 2024 U.S. Presidential Election, where public sentiment and political rhetoric can escalate to extremes.</p>
<p>Offensive language on social media is not merely a question of uncivil discourse. From a scientific standpoint, it poses significant risks to social stability, psychological well-being, and the integrity of the democratic process. The term “offensive language” in this study aligns with definitions commonly used in computational social science and natural language processing (NLP). Specifically, offensive language is defined as any text that includes insults, profanity, or direct attacks against a person or group. This can include explicit slurs, as well as more subtle derogatory remarks targeting an individual’s identity, beliefs, or affiliations. Established datasets such as the Offensive Language Identification Dataset (OLID) have made it possible to develop robust machine learning models that detect these linguistic features with high accuracy (Zampieri et al., 2019). Building on these efforts, the present research aims to explore how offensive language patterns manifest over time and among different user groups during the 2024 U.S. election period.</p>
<p>Why Study Offensive Language on Twitter During the Election?</p>
<p>Elections represent moments of intense political mobilization and public scrutiny. They also tend to attract a significant increase in online activity, with Twitter serving as a central hub for discussions, news circulation, and campaign strategies. In this high-stakes environment, offensive language can have a magnified impact:</p>
<p>Influence on Public Opinion: Political tweets with offensive content can skew public perceptions of candidates, policies, or social groups. Such tweets, if widely circulated, may distort the democratic debate by amplifying divisive voices.</p>
<p>Voter Engagement: Hostile or threatening language can discourage civic participation by instilling fear or discomfort in potential voters. Marginalized communities, in particular, may become dissuaded from engaging in political discussions.</p>
<p>Online Radicalization: Repeated exposure to offensive or hateful content can normalize extremist viewpoints, contributing to online radicalization and, in some cases, offline violence.</p>
<p>Platform Governance: Understanding the prevalence and characteristics of offensive tweets can help social media platforms refine their content moderation policies. This is especially relevant during elections, when the stakes for misinformation and harassment are considerably higher.</p>
<p>Motivation and Theoretical Underpinnings</p>
<p>From a theoretical perspective, the phenomenon of offensive language can be framed through several scholarly lenses:</p>
<p>Agenda-Setting Theory: Media and prominent social accounts can set the tone of public debate, effectively determining which topics gain traction. Offensive tweets by influential figures may shift public attention or legitimize hostile rhetoric.</p>
<p>Social Identity Theory: People often gravitate toward in-groups that share their beliefs and values, while displaying hostility toward perceived out-groups. Offensive language may be used as a boundary-making device, reinforcing group identity and excluding those who do not belong.</p>
<p>Uses and Gratifications Theory: Individuals may use social media platforms to vent frustrations, express strong emotional reactions, or seek attention. Offensive tweets can thus be a manifestation of broader psychological and social needs.</p>
<p>Real-World Illustrations and Significance</p>
<p>Historical data from previous election cycles offers valuable insights. For example, during the 2020 U.S. Presidential Election, multiple studies documented surges in racially charged or inflammatory language coinciding with high-profile events like debates, policy announcements, or controversies involving candidates. Some campaigns actively addressed this phenomenon by issuing statements condemning hateful speech, while others saw their supporters double down on offensive rhetoric. These examples underscore how offensive language is not only a product of isolated individuals but can be shaped—or even orchestrated—by larger political dynamics.</p>
<p>The real-world implications extend beyond the online sphere. Harassment campaigns and sustained offensive language on Twitter have been tied to decreased well-being among targeted groups. In extreme cases, such content may also facilitate radicalization and violence. Notably, social media discourse can feed back into mainstream media coverage, which can further amplify divisive rhetoric. Thus, the study of offensive language is critical for understanding a broader socio-political ecosystem in which online and offline spaces intersect.</p>
<p>Research Questions</p>
<p>To systematically investigate these issues, this study addresses four primary research questions:</p>
<p>Can we build an accurate model to predict offensive language in tweets? We will leverage the OLID dataset—a labeled corpus specifically designed for offensive language identification—to train and validate a supervised machine learning model. This approach enables us to gauge the feasibility and reliability of automated detection.</p>
<p>How is offensive language distributed over time during the 2024 U.S. election? Once the model has been validated, it will be used to classify tweets collected throughout the election cycle. We will quantitatively measure how offensive content fluctuates over daily or weekly intervals, identifying spikes and potential correlating events.</p>
<p>How is offensive language distributed geographically in the U.S. during the election? Geotagged tweets will allow us to map the prevalence of offensive language across different states. This analysis can reveal regional patterns and potential socio-demographic drivers of online hostility.</p>
<p>How is offensive language distributed among Twitter users? We will evaluate whether a small group of users produces the majority of offensive tweets or if such behavior is more widespread. This distribution is crucial for informing moderation strategies—if offensive content is concentrated among a few users, targeted interventions may suffice. Conversely, if offensive tweets are dispersed across the user base, a broader, platform-wide policy response might be necessary.</p>
<p>Importance and Broader Implications</p>
<p>The findings from this study have multiple implications:</p>
<p>Policy and Regulation: By revealing the prevalence and drivers of offensive language during a critical political event, policymakers can design more targeted interventions or regulations to preserve constructive public discourse.</p>
<p>Platform Governance: Our results can inform social media platforms’ moderation strategies, helping them refine algorithms and policies to detect and mitigate harmful content more effectively.</p>
<p>Public Awareness: For journalists, educators, and the general public, understanding the mechanisms and spread of offensive language can promote more critical consumption of social media content and encourage responsible engagement.</p>
<p>Methodological Advancements: This research will contribute to computational linguistics and NLP by examining how well machine learning models generalize to new, event-specific contexts, such as the 2024 election.</p>
<p>Ultimately, by combining large-scale computational analysis with nuanced sociopolitical theories, this investigation aims to offer a comprehensive view of how offensive language influences, and is influenced by, the shifting tides of political discourse. In doing so, it endeavors to fill empirical gaps in current literature while providing actionable insights for stakeholders who wish to maintain a more respectful and inclusive online environment during high-stakes political events.</p>
<!-- Page 5: Data and Methods -->
</section>
<section id="data-and-methods" class="level1">
<h1>Data and Methods</h1>
<p>Explain the nature of your data, how it was collected, and the specific methods or models used for analysis. You might include details such as sampling approaches, preprocessing steps, and any statistical or machine learning techniques applied.</p>
<!-- Page 6: Results -->
</section>
<section id="results" class="level1">
<h1>Results</h1>
<p>Present your main findings. Consider including statistical measures, key observations, or a brief discussion of significant trends/patterns in the data.</p>
<!-- Page 7: Appendix -->
</section>
<section id="appendix" class="level1">
<h1>Appendix</h1>
<p>Put additional or supplementary material here. This could include extended tables, extra figures, or detailed methodological notes that would otherwise clutter the main text.</p>
<!-- Page 8: References -->
</section>
<section id="references" class="level1">
<h1>References</h1>
<p>List your references here. Use your preferred citation style (e.g., APA, MLA, Chicago) and be sure to include all sources cited within the text.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>